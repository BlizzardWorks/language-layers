#+TITLE: Teaching the Ancients to Type: Better Unicode Text Entry for Ancient Greek and Hebrew
#+SUBTITLE:
#+AUTHOR: Steven Tammen
#+DATE: June 24, 2018
#+OPTIONS: toc:2


#+LaTeX_HEADER: \usepackage{fontspec}
#+LaTeX_HEADER: \setmainfont[BoldFont={Gentium Basic Bold}, ItalicFont={Gentium Basic Italic}]{Gentium Plus}

#+LaTeX_HEADER: \usepackage{polyglossia}
#+LaTeX_HEADER: \setmainlanguage{english}
#+LaTeX_HEADER: \setotherlanguage{hebrew}
#+LaTeX_HEADER: \newfontfamily\hebrewfont{SBL Hebrew}


* Section 1: Why?

** Why this project?

Multilingual text input is a solved problem. By this I mean that at the time of writing, it is possible with various existing software options to enter text in multiple different scripts (e.g., Greek, Hebrew, Cyrillic, Arabic, Devanagari) across all of the major operating systems, with relative ease.

So why bother working on another project addressing these things? It's a fair question.

*** To combat the lack of open source, /customizable/ software

This section will use the present state of Greek text input as an example to illustrate how customizable software is currently lacking. Similar situations and observations hold for other languages that I have knowledge of, but will not be discussed for brevity's sake.[fn:1]

**** Current options for Greek text input

{Todo: discussion of various already existing software options. List from Bibliography, explicit coverage of system options.}

**** Positive characteristics

Among different options one can observe several important design characteristics. Some (which? be specific) solutions are /homophonic/, meaning that alpha is put on the A key, beta on the B key, and so forth. Some (which? be specific) attempt to avoid complex chord sequences when entering diacritical marks by using punctuation-based mnemonics. Some (which? be specific) allow flexible entry order, meaning that breathing-then-accent or accent-then-breathing (for example) both correctly display. Many (which? be specific) allow for text entry across applications rather than having to copy and paste out of some "special" window. All of these things are definite positives for a typist, especially one switching into Greek text entry from time to time while primarily typing in his/her native language.

**** Customization and open source

However, users who wish to customize things are out of luck with present options. Some people may wish to change how diacritics are handled, for example, or to change which English letter chi goes on to conform to their preferences (both C and X are popular, but it is irritating to have to deal with both mappings). Because current options are closed source without significant customization interfaces, this is simply not possible.

Customization and open source software go hand-in-glove, and especially for a program such as this -- which is dealing with a very domain-specific problem that contains much that is subjective and/or related to user preference -- there is significant benefit to making software community-driven. 

Of course, open source software has some other benefits as well. Open source software is free and relatively more stable than close sourced software. There is never a guarantee of long-term stability with programs that do not publish their source code, since if the projects stop getting maintained (a company goes out of business, e.g., or the primary developer dies suddenly), nobody else can pick them up and keep the code running smoothly on new hardware and/or operating system environments. This is actually a somewhat greater concern for projects of this sort: since programs dealing with keyboard layouts must depend on system calls to interface with keyboards, they are necessarily less insulated from the operating system environment than many other kinds of programs. In other words, if an operating system changes one of its low-level libraries for handling streams of keys, it will likely break a program dealing with keyboard layouts, while a browser or music player might still work just fine.

If I were forced to pick "just one" reason why this project existed, it would be this: to create a customizable and open source framework for text entry of non-native languages.

*** To combat the lack of software that bundles multiple language layouts together

This software is being developed in close association with Classicists, and the initial project scope is, in many ways, targeted at solving the problems of Greek scholars in this field. However, I am trying to create a framework that may be comfortably extended to other languages and alphabets as needed.

Some academic fields (e.g., Historical Linguistics, Classics, Ancient Near East, and Ancient History), have significant language demands. It is not uncommon for people studying in these fields to pick up multiple ancient languages (including, but certainly not limited to, Latin, Greek, Hebrew, Arabic, Syriac, and Sanskrit), with many of these having complex alphabets. A lack of consistency in approaches can be frustrating, particularly if one has to go through the bother of installing and updating text entry solutions for all these languages on all the computers used for writing.

Additionally, much secondary scholarship in these fields is in German, French, and Italian, all of which share the basic English character set, but demand a few special characters and/or accents. It is conceivable for a scholar working on research about Mediterranean trade in Late Antiquity, for example, to need to type in English for their core analysis, Latin, Greek, and Syriac for primary sources, and German, French, and Italian for secondary sources. Assuming Latin is typed without macrons and accents, that leaves 5 additional languages on top of English that must be dealt with.

While it is more a future goal than a priority of "round 1" of this project, bringing multiple language layouts together in the same program is one of the central motivations behind creating another project dealing with these things. Starting from scratch rather than adding on to an existing program ensures that there will be seamless interoperability in the future, and that standards and design guidelines may be established.

*** To combat the lack of software that adds functionality without removing any

Using keyboard shortcuts can be a frustrating experience when you have to type in another language. If there is no intelligent handling of modifier keys, people typing in a non-native language might miss such shortcuts as Ctrl-C (copy), Ctrl-X (cut), Ctrl-V (paste), Ctrl-Z (undo), and Ctrl-S (save). The situation is especially bad for those who use Vim, Emacs, or other text editors that make use of the keyboard (rather than a GUI) for functionality, and for people who use keyboard-driven window managers, browsers, application launchers, window switchers, and so on.

It can also be frustrating to "lose access" to some English keys (typically punctuation such as brackets) when typing in another language. If a language layer "steals" English punctuation keys thinking that they will never be needed when typing that language, but does not provide any way to access said keys short of disabling the software temporarily, it can create an unpleasant user experience.

Things like these are not the most obvious design factors when one thinks of typing in non-native languages, but it has been my experience that these are actually almost as important as the layout design itself. The devil truly is in the details.

*** To combat the lack of software that works for nonstandard keyboard layouts

Another reason for the creation of this project in particular is the fact that currently available homophonic layouts (at least those that function at the system level) do not work for "nonstandard" keyboard layouts -- they all assume a QWERTY base mapping.

People typing on Dvorak, Colemak, QWERTZ, BÉPO, and so forth may wish to have the benefits of homophonic letter layouts in their non-native languages while retaining their native base mapping. Portability is a high priority of this project, and all of the functionality in any language can be implemented on whatever base layout is desired, with full customization as an option.

** Why this paper?

*** Justifying design choices

This paper is intended to fill the void between low level implementation details (Should arrays or strings be used to send keys? Global variables or classes?) and the end result of fully functioning keyboard layouts.

I personally find it extremely frustrating when design decisions have no specific thought process behind them. For this reason I am attempting to document things in such a way that I would be satisfied as a user of this software, if I were not the one designing it in the first place. The placement of letter keys, the choice of particular punctuation keys for diacritics, the mechanism for switching languages, the process of entering "normal" punctuation when on a non-native layer; these are the sorts of design decisions that this paper sets out to explain.

The idea is to have something to point to when someone asks, "but why?" Rather than saying "just because" or trying to come up with rationalizations /ex post facto/, attempting to rigorously justify everything from the get-go should lead to a project wherein there are not an abundance of arbitrary program characteristics. At least in theory.

*** Creating a starting point for people that may have different opinions than myself

With all this being said, this paper is certainly not attempting to close discussion on these topics or be the last word on design factors. At the time of writing, I have worked with Greek for approximately two years, and any sort of serious coding for about as long. I am sure one could easily find people more qualified than myself for virtually any aspect of this project, and even all of them put together.

Instead, the idea is start a conversation about these things in a more formal manner. I am certain that Classicists, for example, are opinionated about how they wish to type Greek, and things that drive them crazy about current options that let them type Greek. If this paper can present one rationale that can be critiqued and examined, and the code behind this project is designed in such a way that it is sufficiently flexible, it should be possible in the future for this project to come to encompass multiple points of view, and circle in on an increasingly sophisticated understanding of the design variables in play.

{Todo: maybe mention survey and results here?}

* Section 2: Nuts and bolts

Before getting into this project in particular, it is proper to briefly examine the nuts and bolts that make multilingual text input a possibility on modern operating systems. Much more could be written about any of the things here, but the present section will seek only to provide a sufficient amount of background to give readers an appreciation for the complexity at play behind the scenes.

** Keyboard layouts

To be able to type in a language that is not the default for your physical keyboard and system layout (e.g., a QWERTY ANSI keyboard used for American English), a different keyboard layout is necessary. In essence, a keyboard layout translates presses of physical keys into characters or key events (like Enter or Tab).[fn:7] I find it helpful to split up keyboard layouts for languages into smaller semantic groupings to make them easier to think about, especially for people that must implement them in software.

*** Letters

For languages with alphabets ({Todo: footnote: as opposed to syllabaries or Abjads}), keyboard layouts must provide a means for typing all of the letters. English has 26 letters, but other languages often have more or less.

Letters may be further subdivided into vowels and consonants. Vowels are typically the more interesting variety inasmuch as most markup (such as accents) revolves around vowels, and therefore they typically require more work to integrate into the layout. For example, Greek vowels may take accents, breathings, iota subscripts, and so forth, while Greek consonants (with the exception of rho) take none of these things. This means that designers do not need to keep track of consonants as closely as vowels, generally speaking.

Many languages have uppercase and lowercase letterforms, but not all languages do. Hebrew, for example, does not have any casing distinctions. In general, implementing uppercase forms involves keeping track of shift state, but not too much extra work other than that.

*** Context-specific/alternate letter forms

Some languages have letters that change their form based upon their position in words. For example, word-final sigma in Greek changes forms, and many letters in Hebrew and Arabic also exhibit this behavior.

Semantically, the letter is still the same, and should not therefore be thought of as a new or different entity. However, implementing positional letterforms does require some extra work, particularly in terms of identifying word boundaries. One approach to handling final forms is replacing the base form with the final form when and only when a key signifying a word boundary (such as Space or .,?!) is pressed immediately following a letter with final form behavior.

In addition to final forms, some languages have alternate forms of letters. In Hebrew, for example, some of the so-called Begadkephat letters (tav, dalet, gimel) have alternate forms for when they are aspirated, while others (bet, khaf) fully change their phonetic value through an alternate form. The line here can be a bit blurred between these alternate forms (which use a mark called a dagesh) and letters with diacritics. The dagesh can be used with other Hebrew consonants to double phonetic value, for example, which could be considered a separate use. But the same mark is used.

For simplicity in programming, I recommend structuring development around /program features/ (for example, the ability add a dagesh to things... alternate form or no) rather than /language features/ (for example, working on developing the capacity to support all possible sounds in a language, including aspirated forms and those that optionally change their phonetic value). This allows the designer of a keyboard layout to focus on one thing at a time, rather than trying to organize development around language features that may not cleanly map onto structured commits. As long as pains are taken not to forget any essential language features, this approach is easier on the programmers while accomplishing the same goals.

*** Mandatory markup: vowel points, diacritics, etc.

*** Additional markup: metrical marks, cantillation marks, etc.

*** Punctuation; language-specific symbols

** Unicode

*** History, scope, and purpose; peculiarities

*** Precomposed and decomposed Unicode

*** Combining multiple diacritics

** Fonts

{Todo: [fn:2]}

*** An overview of existing options (for Greek and Hebrew)

- SBL Greek and Hebrew
- Gentium Plus and Ezra SIL
- Cardo
- New Athena Unicode
- Google Noto Font. Research.

* Section 3: The Unicode Language Layers project

** Sane defaults combined with ease of use

- Letters, diacritics, etc. At least have "some reason" for placements of everything
- Defaults should match up to the "normal user" and what they would find best

** Customizability as a first order priority

- Thorough API
- In-line comments
- Examples in the form of Greek and Hebrew layers

** Minimal interference with normal computer use

- Quick and easy on and off
- Consistent keyboard shortcuts (languages do not interfere with normal shortcuts)
- Leader-prefixed punctuation for normal behavior (for when punctuation gets hijacked by a layer for diacritics and so forth)

** Consistency across multiple languages

*** For end users

- Base markup for Latin, German, French, Italian, Spanish. Leader-prefixed diacritics.
- Switching between different alphabets; using different alphabets

*** For designers

- Consistent handling of precomposed and decomposed Unicode
- Abstracted, language-blind functions to extend to new languages with minimal effort
- If you understand how to code a layer for one language, you should be able to code layers for other different languages.

* Section 4: Greek as an example

** Letters

*** The relationship between memorability and speed

Touch typing is a skill acquired over time through practice. Given that most individuals typing ancient languages in scholarly pursuits (e.g., Classicists, Ancient Near East scholars) will not need to enter large amounts of text in ancient languages, and will not need to do it with great frequency, it is worth considering the time-cost associated with learning keyboard layouts for ancient languages.

Keyboard layout design is a complicated process with many optimization variables. Today, layouts may be judged using algorithms like {Todo}, which track many metrics that are likely associated with performance. I say likely, because there has not been formal scholarship on the subject done in such a way that we may be sure about such things. Part of the problem involves the difficulty in doing research: you cannot blind research about keyboard layouts (people must know the layout they are typing on), you cannot have a realistic control group (everyone who has used computers already has varying levels of experience typing on keyboards -- even people who hunt and peck have cognitive maps of their layout), and many things that one might want to measure -- most notably comfort and repetitive stress -- are difficult to get good, objective measurements for.

With all this said, there are some things that are not controversial. Having more commonly typed characters on the home row leads to less hand movement and theoretically faster speeds. Avoiding having the same finger type multiple keys in a row (cf. QWERTY's "minimum") enables the typist to "line up" fingers when typing, so that multiple keys may be in the process of being pressed at once.[fn:3] Having work split between the hands is more balanced than having it all concentrated on one hand (cf. QWERTY's "stewardesses").

As a general rule of thumb, so-called "fully optimized" layouts will have relatively poor memorability. If you let a genetic algorithm design an optimized layout for you, it will not keep all the letters in a block or numbers in a row, but mix everything together according to frequency considerations. We humans are very pattern-oriented creatures, and having no apparent structure to characters will make a keyboard layout more difficult to remember, to some degree. Furthermore, it is obvious that keyboards that are easier to remember will be easier to get up to speed with.

The issue in all this is that due to a lack of research, I cannot say definitely how much easier semantically-grouped keyboard layouts are to learn, or how much faster people may train them to, say, 35 WPM. The data for this simply does not exist. However, this paper is operating on the safe assumption that these considerations are non-negligible for most people in most circumstances. The hypothesis coming from this is this: since people typing ancient languages will not be typing them with great magnitude and frequency, it is more rational to focus on memorability over raw optimization considerations, since layouts that are easier to remember will be faster to learn, and the benefits of "brute forcing" an optimized layout (as one might do for one's native language) will never be realized in typical use cases.

*** Native-language layouts in muscle memory

The above discussion focused on the interplay of memorability, layout optimality (as measured by finger travel distance, same finger, etc.), and ease of acquisition in the abstract. However, assuming users of this project can already type on a keyboard layout in their own language (in whatever regard: touch typing, hunting and pecking, etc.), we do not need to start from ground-zero.

The general idea is that for the circumstances under which most scholars type ancient languages it is /always/ better to associate a keyboard layout for an ancient language with a keyboard layout for a native language already in muscle memory. Associating a new layout with the old layout lets typists reuse neural pathways that are already in place rather than forming new ones from scratch.

What do I mean by this? Let's take the Greek letter alpha. Most people, Classicists or no, know that alpha corresponds in phonetic value to the English letter A. Alpha also happens to look like the letter A in both its lowercase and uppercase forms. So, rather than putting alpha on some random key, why not simply place it on the same key as the letter A in English?

*** Issues in constructing associations

If we accept the premise that it is best to form correspondences between ancient languages and keyboard layouts already in use (for English or otherwise), then it follows that we need some formalized system for doing so.

Layouts derived from phonetic matching are typically called "homophonic layouts." While homophonic layouts are excellent when correspondences exist, there are some letters in languages that have no clear English equivalent. Theta in Greek, for example, corresponds to the phoneme in English that is represented by the digraph "th." These must be dealt with separately.

There are also some cases when a language has two letters for the same phoneme. In Hebrew, for example, the consonant Vet (Bet without a dagesh) is equivalent to the consonant Vav -- they both make "the V sound." So which one should occupy the V key?

The associations (henceforth keymaps, short for "key mappings") below attempt to solve such issues in a systematic way. Following the hypothesis presented above (namely, that memorability is a more important concern in these circumstances than raw optimality), priority is given to phonetic correspondences, then visual correspondences, then transcription correspondences, then, finally, to raw optimality. {Todo: why?}

*** A Greek-English keymap

**** Foreword {Todo: footnote this/put in appendix}

I have attempted to make the above discussion general enough that people with native languages significantly different than English (Russian, say) may easily transfer these ideas into layouts that fit their languages. However, from this point forward, discussion will center around English and languages that have a close association with it (the same general alphabet and phonology)

**** Phonetic correspondences

I have opted to supply the fricative versions of Theta and Phi, according to later developments in the language. People interested in classical 5th century Attic pronunciations can substitute the aspirated plosives if they wish. (I have made this substitution because I have observed that most people learning ancient Greek have a much easier time distinguishing the phonemes this way, and thus avoid mixing up Theta/Tau and Phi/Pi in their writing). {Todo: don't be arbitrary. Explain, don't assume}

If a letter has any English equivalent (even if it has additional sounds in some contexts not found in English), I have opted to match them. I have also opted to match "near misses" -- sounds that aren't quite identical, but are close enough that they are obviously connected (such as the Greek Rho and English R, and many of the vowels). {Todo: handle cases of similar sounds like o/w e/h, etc. Also weighting phonetic correspondence vs. frequency/visual correspondence as with digamma and omega}

| Greek letter | IPA                      | English match |
|--------------+--------------------------+---------------|
| Α α          | [a], [aː]                | A             |
| Β β          | [b]                      | B             |
| Γ γ          | [g], [ŋ] (before velars) | G             |
| Δ δ          | [d]                      | D             |
| Ε ε          | [e]                      | E             |
| Ζ ζ          | [zd]                     | Z             |
| Η η          | [ɛː]                     |               |
| Θ θ          | [θ]                      |               |
| Ι ι          | [i], [iː]                | I             |
| Κ κ          | [k]                      | K             |
| Λ λ          | [l]                      | L             |
| Μ μ          | [m]                      | M             |
| Ν ν          | [n]                      | N             |
| Ξ ξ          | [ks]                     | X             |
| Ο ο          | [o]                      | O             |
| Π π          | [p]                      | P             |
| Ρ ρ          | [r]                      | R             |
| Σ σ          | [s]                      | S             |
| Τ τ          | [t]                      | T             |
| Υ υ          | [y], [yː]                | U             |
| Φ φ          | [f]                      | F             |
| Χ χ          | [kʰ]                     |               |
| Ψ ψ          | [ps]                     |               |
| Ω ω          | [ɔː]                     |               |

This "first pass" at matching gets us pretty far - only 5 letters remain unmatched.

**** Visual correspondences

Look-alike letters, even if they have no phonetic correspondence, can be an easy way to remember letters. Anything that helps create mental associations can help speed up the learning process. Both uppercase and lowercase forms are considered.

| Greek letter | English match |
|--------------+---------------|
| Η η          | H             |
| Θ θ          |               |
| Χ χ          |               |
| Ψ ψ          | Y             |
| Ω ω          | w             |

Uppercase Eta looks identical to the uppercase form of the English letter H, and lowercase Omega looks very similar to the lowercase form of the English letter W. Uppercase Psi looks similar enough to the uppercase form of the English letter Y that it is worth using as a mnemonic, in my opinion.

Note that while Chi looks very similar to the English letter X, we are already using X to represent Xi.

**** Transcription correspondences

One of the problems with transcription is that it is not terribly standardized. For example, scholars preferring a transcription scheme closer to Greek will typically transliterate Kappa as "k" and chi as "kh" as opposed to the more Romanized "c" and "ch." However, "typical" transcriptions may provide some help in providing mnemonics for our remaining letters.

I have opted to only look at strictly alphabetical transcriptions, rather than any that use diacritics. {Todo: why?}

| Greek letter                           | "Typical" transcription | English match |
|----------------------------------------+-------------------------+---------------|
| Θ θ                                    | th                      |               |
| Χ χ                                    | ch                      | C             |

Chi is transliterated as "ch" in most transcription schemes, even if Kappa is transliterated as "k." So it seems logical to use the letter C to represent chi.

**** Leftovers

Theta is a tricky letter to place, since none of our correspondence efforts appear to help with it. English letters that are left include Q, V, and J.

None of these letters is particularly satisfying as a choice, but J is probably the best for people that type on QWERTY or its variants (like AZERTY, e.g.), since it is on the home row and does not have any same finger with vowels. For this reason, I have made it the default mapping for theta. People that do not type on QWERTY (Dvorak, Colemak, Workman, etc.) may want to alter this location, depending. I type on a custom layout and kept it on J because it was still the best location.

As to Q and V, I have these default to Koppa and Digamma, respectively. Both of these come from earlier forms of Greek that are closer to the Phoenician, but may be useful to type on occasion. For people that read on for the Hebrew keymap, Koppa~Quf and Digamma~Vav, so Q and V are actually logical choices given the Semitic consonants underlying these letters.

Digamma dropping explains the -ευς declension and the development of certain stems and words. For example, βασιληϝ- to Βασιλεύς, νηϝ- to ναῦς, βοϝ- to βοῦς, and so on.

Koppa can be also be useful in explaining language development, as can the third and last early Greek letter: San (allophonic with Sigma). {Todo: explain how to generate San}

** Context-specific/alternate letter forms

*** Final sigma

*** Lunate sigma

** Mandatory markup

*** Breathings

- smooth, rough
- vowels and rho

*** Accents

- acute, grave, circumflex

*** Iota subscripts

*** Diaeresis

*** The koronis

** Additional markup

*** Vowel quantity: macrons and breves

*** The underdot

** Punctuation; language-specific symbols

*** Question marks and semicolons

*** A discussion of "hybrid" punctuation, and accessing normal punctuation when desired

{Todo: [fn:4]}

* Section 5: Hebrew as an example

** Letters

*** Handling cases of identical letter sounds

*** A Hebrew-English keymap 

** Context-specific/alternate letter forms

*** Word final letters: the sofit forms

*** The Begadkephat letters

*** Shin and Sin

** Mandatory markup

*** A note about opinionated design decisions

- "Case study" -- the /matres lectionis/ letters. Automatically including vav and yod when they are vowel indicators.

*** Basic vowel points

*** Shva and reduced vowels

*** The dagesh

** Additional markup

*** The meteg

*** Cantillation marks

** Punctuation; language-specific symbols

*** A discussion of languages that use "mostly normal" punctuation (from the English point of view)

*** The geresh

*** The gershayim (lit. "double geresh" -- this word is plural)

*** Colon and /sof pasuq/

*** Vertical bar and /paseq/

*** Hyphen and /maqaf/

*** Shekel symbol

* Section 6: Efficient typing practice for non-native languages

** Introduction to efficient typing

*** Practicing based on word frequency

*** Practicing based on N-gram frequency; affixes

- (Derivational) Morphemes rather than words as a training focus

*** Abbreviating very frequent words and phrases

*** Practicing the sorts of texts you are going to type

** Creating necessary resources

*** Word frequency tables

- Perseus, TLG, handling overlapping forms

*** N-gram frequency tables

- Similar process. Handling semantic boundaries in regexes? How to automate morphological analysis without obvious delimiters like spaces for words?

*** Area-specific practice texts

- Downloading from free/uncopyrighted sources. Perseus, Project Gutenberg.[fn:5]

** Typing practice

*** Amphetype

*** Lesson generation from frequency tables and practice texts

** Crossover benefits

*** Vocabulary lists by frequency for specific domains

*** Morphological analysis and generative vocabulary

- Prefixes, suffixes, and roots. Developing an eye for picking up meanings automatically, simply by knowing what different parts of the word mean in general.

* Section 7: Pedagogical applications

** Orthography for digital natives

*** Standardization of letterforms

- Reducing the learning load in the first few weeks of Hebrew: block scripts and cursive scripts.
- Possible in handwritten as well (just only writing in block)

*** Typing speed and writing speed

*** But the permanence of handwriting

- Tests

** Examples of typing-related pedagogical aids for Greek

*** Learning the accentuation system

- Practicing the typing of accents while learning about the rule of contonation, morae, and recessive accents.

*** Common irregular verbs

-	Practicing the typing of certain very common irregular verbs (like /eimi/, e.g.) while simultaneously learning their paradigms.

*** Practicing reading/speaking Greek; "reading by typing"

-	Practicing typing in general by pulling in Greek texts from Perseus as typing training material. Students could be encouraged to also read the texts out loud as they type them. (Not necessarily understanding the Greek, but getting to see how it sounds and flows).

* Section 8: Concluding remarks

** Specific implementation benefits

*** Who should make the switch to this system? Is this project really worthwhile?

*** The low opportunity cost for the next generation

** Moving forward with more languages

*** Current project: focus on Greek with Hebrew as a foil

*** Possibility to expand much further

** Suggestions for further research

*** Corpus generation

*** Morphological analysis

*** Graphical frontends for customization

*** System APIs for keystream manipulations /across platforms/

*** AI autograders for language exercises

* Section 9: Appendix

** Integrating general electronic/online resources into classes

***  Language input as a pain point

- A lack of good keyboard input is a significant damper to the use of electronic/online resources.

*** The value of electronic/online resources

**** Elecronic lexica and morphology parsers

Dangers of over-reliance, but great benefits all the same. Arbitrary searches (those that require the ability to type native text) can be necessary when using paper sources rather than cross-linked sources like those on Perseus.

**** Searches

- Fuzzy search (i.e., lemma search), finding passages and references, searching on word usage or specific form.
- Searching typed notes, if people type class notes

**** Electronic flashcards

More polarizing whether or not they are useful, but making them easier to construct is definitely a good thing. Spaced repetition studying, Anki.

**** Autograded sentences

-	Practicing typing in general by providing form-fields to enter sentence translations. Depending on the difficulty of implementation, it might be possible to create an autograder for practice sentences in Athenaze, for example. If care was taken to follow vocabulary acquisition (so as to limit the lexicon input for the program and make it deterministic), it would be easy for professors to design supplemental/optional practice exercises that the students could complete with instant feedback and no extra work for the professor.

** Word Processing

*** Font testing: Gentium Plus + SBL Hebrew

Here is some inline Hebrew from the beginning of Genesis 1 \texthebrew{‏בְּרֵאשִׁ֖ית בָּרָ֣א אֱלֹהִ֑ים אֵ֥ת הַשָּׁמַ֖יִם וְאֵ֥ת הָאָֽרֶץ׃ ‎2‏ וְהָאָ֗רֶץ הָיְתָ֥ה תֹ֨הוּ֙ וָבֹ֔הוּ וְחֹ֖שֶׁךְ עַל־פְּנֵ֣י תְה֑וֹם וְר֣וּחַ אֱלֹהִ֔ים מְרַחֶ֖פֶת עַל־פְּנֵ֥י הַמָּֽיִם׃ ‎3‏ וַיֹּ֥אמֶר אֱלֹהִ֖ים יְהִ֣י א֑וֹר וַֽיְהִי־אֽוֹר׃ ‎4‏ וַיַּ֧רְא אֱלֹהִ֛ים אֶת־הָא֖וֹר כִּי־ט֑וֹב וַיַּבְדֵּ֣ל אֱלֹהִ֔ים בֵּ֥ין הָא֖וֹר וּבֵ֥ין הַחֹֽשֶׁךְ׃} with English around it. And now a block:

#+BEGIN_QUOTE
\begin{hebrew}
‏‏בְּרֵאשִׁ֖ית בָּרָ֣א אֱלֹהִ֑ים אֵ֥ת הַשָּׁמַ֖יִם וְאֵ֥ת הָאָֽרֶץ׃ ‎2‏ וְהָאָ֗רֶץ הָיְתָ֥ה תֹ֨הוּ֙ וָבֹ֔הוּ וְחֹ֖שֶׁךְ עַל־פְּנֵ֣י תְה֑וֹם וְר֣וּחַ אֱלֹהִ֔ים מְרַחֶ֖פֶת עַל־פְּנֵ֥י הַמָּֽיִם׃ ‎3‏ וַיֹּ֥אמֶר אֱלֹהִ֖ים יְהִ֣י א֑וֹר וַֽיְהִי־אֽוֹר׃ ‎4‏ וַיַּ֧רְא אֱלֹהִ֛ים אֶת־הָא֖וֹר כִּי־ט֑וֹב וַיַּבְדֵּ֣ל אֱלֹהִ֔ים בֵּ֥ין הָא֖וֹר וּבֵ֥ין הַחֹֽשֶׁךְ׃
\end{hebrew}
#+END_QUOTE

And here is some inline Greek from the /Iliad/ μῆνιν ἄειδε θεὰ Πηληϊάδεω Ἀχιλῆος with English around it. And now a longer chunk:

#+BEGIN_QUOTE
μῆνιν ἄειδε θεὰ Πηληϊάδεω Ἀχιλῆος οὐλομένην, ἣ μυρί᾽ Ἀχαιοῖς ἄλγε᾽ ἔθηκε, πολλὰς δ᾽ ἰφθίμους ψυχὰς Ἄϊδι προΐαψεν ἡρώων, αὐτοὺς δὲ ἑλώρια τεῦχε κύνεσσιν οἰωνοῖσί τε πᾶσι, Διὸς δ᾽ ἐτελείετο βουλή, ἐξ οὗ δὴ τὰ πρῶτα διαστήτην ἐρίσαντε Ἀτρεΐδης τε ἄναξ ἀνδρῶν καὶ δῖος Ἀχιλλεύς. τίς τ᾽ ἄρ σφωε θεῶν ἔριδι ξυνέηκε μάχεσθαι;
#+END_QUOTE



*** Reasons why something other than Word might be desirable

- Automatic font use rather than manual switching

*** Example: Emacs' Org mode to PDF using XeLaTeX

- Support for RTL languages and automatic display
- Polyglossia
- Automatic font switches

*** Yudit?

{Todo: [fn:6]}

** Abbreviations

- More of a personal thing. Can algorithmically generate in theory. (Outside scope of this project).
- Probably good to look at the 10 or 15 most common words and see if anything jumps out at you
- Creating regex hotstrings in this particular AHK implementation.

* Footnotes

[fn:7] To be more precise, keyboards send hexadecimal scancodes that are interpreted by the operating system kernel. Depending on permissions, different programs can inject themselves into the input system, and intercept keypresses before they get sent to other programs. This is what allows a remapping program to change the behavior of sent keys: the scancodes sent by the physical keyboard are the same, but they are intercepted and replaced with virtual key codes that encode different behavior.

[fn:1] Discussion of options from research in Hebrew. Maybe put in Appendix somewhere?

[fn:2] Ideal font design + discussion

[fn:3] While I don't know of a formal source for numbers, many expensive keyboards market themselves as being better for fast typists due to allowing for so-called "n-key rollover" (NKRO), which lets many keys be pressed simultaneously, as opposed to the 6-key rollover of most USB keyboards.

[fn:4] Metrical marks, special numerals, drachma symbol

[fn:5] Automate with script? Probably also outside scope of project.

[fn:6] Need to research more.

